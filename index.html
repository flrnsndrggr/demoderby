<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>Fish Duel P2P</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height:100%; width:100%; margin:0; padding:0; background:#0b0f14; overflow:hidden; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    #ui { position:fixed; inset:0; pointer-events:none; }
    #hud { position:absolute; top:12px; left:12px; display:flex; gap:6px; align-items:center; pointer-events:none; }
    .heart { width:24px; height:24px; filter: drop-shadow(0 0 6px rgba(255,0,70,.4)); }
    #status { position:absolute; top:12px; right:12px; pointer-events:auto; }
    .pill { display:inline-flex; align-items:center; gap:8px; padding:8px 12px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.15); border-radius:999px; backdrop-filter: blur(6px); font-size:12px; }
    .btn { cursor:pointer; padding:6px 10px; border-radius:8px; border:1px solid rgba(255,255,255,.2); background:rgba(255,255,255,.1); pointer-events:auto; }
    .btn:hover { background:rgba(255,255,255,.18); }
    #shareLink { max-width:46vw; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    #center { position:absolute; inset:0; display:grid; place-items:center; pointer-events:none; }
    #crosshair { width:16px; height:16px; border:2px solid rgba(255,255,255,.8); border-radius:50%; box-shadow:0 0 0 2px rgba(255,255,255,.2) inset; }
    #overlay { position:fixed; inset:0; display:grid; place-items:center; background:radial-gradient(1200px 600px at 50% 0%, rgba(22,28,36,.85), rgba(11,15,20,.95)); color:#e7edf3; }
    #card { width:min(680px, 92vw); padding:24px; border-radius:16px; background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04)); border:1px solid rgba(255,255,255,.16); box-shadow:0 10px 40px rgba(0,0,0,.35); }
    h1 { margin:0 0 8px 0; font-size:28px; letter-spacing:.5px; }
    p { margin:6px 0; opacity:.9; }
    code { padding:2px 6px; background:rgba(255,255,255,.08); border-radius:6px; }
    #startBtn { margin-top:14px; padding:12px 16px; border-radius:12px; border:1px solid rgba(255,255,255,.25); background:#23b2ff1a; color:#e7edf3; cursor:pointer; }
    #footerHint { margin-top:10px; font-size:12px; opacity:.8; }
    #toast { position:fixed; bottom:16px; left:50%; transform:translateX(-50%); background:rgba(10,14,18,.8); color:#e7edf3; border:1px solid rgba(255,255,255,.18); border-radius:12px; padding:8px 12px; box-shadow:0 10px 30px rgba(0,0,0,.4); display:none; }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="overlay">
    <div id="card">
      <h1>Fish Duel P2P</h1>
      <p>1v1 browser duel. Left click throws a fish. Right click swings a giant baguette. Three hits and you lose.</p>
      <p>Move with <code>WASD</code>, look with mouse. <code>R</code> to respawn, <code>Esc</code> to unlock cursor, <code>N</code> to mute.</p>
      <p>Share the link shown in the top right to invite exactly one opponent. No logins, no popups.</p>
      <button id="startBtn">Start</button>
      <div id="footerHint">Pointer Lock and Audio require a click to start.</div>
    </div>
  </div>

  <div id="ui">
    <div id="hud"></div>
    <div id="status" class="pill">
      <span id="connState">Idle</span>
      <span id="shareLink"></span>
      <button id="copyBtn" class="btn" title="Copy link">Copy</button>
      <button id="muteBtn" class="btn" title="Toggle audio">Mute</button>
    </div>
    <div id="center"><div id="crosshair"></div></div>
  </div>

  <div id="toast"></div>

  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script>
  // Utils
  const randId = (n=6)=> Array.from(crypto.getRandomValues(new Uint8Array(n))).map(x=> (x%36).toString(36)).join('');
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;

  // URL room
  const ensureRoomUrl = ()=>{
    const url = new URL(location.href);
    if (!url.hash) { url.hash = 'r-' + randId(8); history.replaceState(null, '', url.toString()); }
    return location.hash.slice(1);
  };

  // Audio
  const SFX = (()=>{
    const ctx = new (window.AudioContext||window.webkitAudioContext)();
    let muted = false;
    const env = (f=440, d=.12, type='square', g=.06)=>{
      if (muted) return { stop:()=>{} };
      const t = ctx.currentTime, o = ctx.createOscillator(), gain = ctx.createGain();
      o.type = type; o.frequency.value = f;
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(g, t+.01);
      gain.gain.exponentialRampToValueAtTime(.0001, t+d);
      o.connect(gain); gain.connect(ctx.destination); o.start(t); o.stop(t+d+.05);
      return o;
    };
    return { ctx, get muted(){return muted}, toggle(){ return (muted=!muted); }, hit(){env(190,.08,'sawtooth',.08)}, throw(){env(720,.05,'triangle',.04)}, swing(){env(340,.04,'square',.05)}, lose(){env(110,.6,'sine',.12)}, win(){env(520,.5,'triangle',.12)} };
  })();

  // DOM
  const overlay = document.getElementById('overlay');
  const startBtn = document.getElementById('startBtn');
  const hud = document.getElementById('hud');
  const shareLinkEl = document.getElementById('shareLink');
  const connStateEl = document.getElementById('connState');
  const copyBtn = document.getElementById('copyBtn');
  const muteBtn = document.getElementById('muteBtn');
  const toast = document.getElementById('toast');
  const showToast = (msg)=>{ toast.textContent = msg; toast.style.display='block'; setTimeout(()=> toast.style.display='none', 1500); };

  // Three core
  let scene, camera, renderer, clock;
  let local = { hp:3, alive:true, model:null, baguette:null };
  let remote = { hp:3, alive:true, model:null };
  const projectiles = [];
  const world = { size: 80 };

  // Shared geometries/materials for fish (no per-shot allocations)
  let GEO, MAT;

  function setupThree() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0f14);

    camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 500);
    camera.position.set(0, 1.7, 6);

    renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    clock = new THREE.Clock();

    const hemi = new THREE.HemisphereLight(0xa0d8ff, 0x203040, 0.6); scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, .7); dir.position.set(10,20,10); scene.add(dir);

    const g = new THREE.PlaneGeometry(world.size, world.size, 32, 32);
    const grid = new THREE.Mesh(g, new THREE.MeshStandardMaterial({ color:0x12202c, metalness:.2, roughness:.8 }));
    grid.rotation.x = -Math.PI/2; scene.add(grid);
    const gridHelper = new THREE.GridHelper(world.size, 32, 0x1e90ff, 0x1b3a52); gridHelper.position.y = 0.01; scene.add(gridHelper);

    const wmat = new THREE.MeshStandardMaterial({ color:0x0f2a3a, metalness:.1, roughness:.9 });
    const wallGeo = new THREE.BoxGeometry(world.size, 4, 0.5);
    const wall1 = new THREE.Mesh(wallGeo, wmat); wall1.position.set(0,2,world.size/2); scene.add(wall1);
    const wall2 = wall1.clone(); wall2.position.set(0,2,-world.size/2); scene.add(wall2);
    const wall3 = new THREE.Mesh(new THREE.BoxGeometry(0.5,4,world.size), wmat); wall3.position.set(world.size/2,2,0); scene.add(wall3);
    const wall4 = wall3.clone(); wall4.position.set(-world.size/2,2,0); scene.add(wall4);

    local.baguette = makeBaguette();
    local.baguette.position.set(0.4, -0.4, -0.8);
    local.baguette.rotation.set(0.3, 0.2, 0.4);
    camera.add(local.baguette);
    scene.add(camera);

    remote.model = makeAvatar(0x49a8ff); remote.model.visible = false; scene.add(remote.model);

    scene.fog = new THREE.Fog(0x0b0f14, 40, 140);
    window.addEventListener('resize', onResize);

    // init shared fish assets once
    GEO = {
      body: new THREE.SphereGeometry(0.18, 16, 12),
      tail: new THREE.ConeGeometry(0.12, 0.28, 12),
      fin:  new THREE.ConeGeometry(0.08, 0.16, 10),
      eye:  new THREE.SphereGeometry(0.03, 8, 6)
    };
    MAT = {
      body: new THREE.MeshStandardMaterial({ color:0x3ea7ff, metalness:.3, roughness:.4 }),
      tail: new THREE.MeshStandardMaterial({ color:0x2b6fb0, metalness:.2, roughness:.6 }),
      fin:  new THREE.MeshStandardMaterial({ color:0x5fc0ff }),
      eye:  new THREE.MeshStandardMaterial({ color:0x000000 })
    };
  }

  function onResize(){ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); }

  // Models
  function makeAvatar(color){
    const group = new THREE.Group();
    const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.3, 1.1, 8, 16), new THREE.MeshStandardMaterial({ color, metalness:.1, roughness:.7 }));
    body.position.y = 1.1; group.add(body);
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.28, 16, 12), new THREE.MeshStandardMaterial({ color:0xffffff })); head.position.y = 2; group.add(head);
    const eye = new THREE.Mesh(new THREE.SphereGeometry(0.05, 10, 8), new THREE.MeshStandardMaterial({ color:0x1e90ff })); eye.position.set(0.08, 2.05, 0.25); group.add(eye);
    const eye2 = eye.clone(); eye2.position.x = -0.08; group.add(eye2);
    return group;
  }

  // Projectile pool (recycle meshes)
  const fishPool = [];
  function acquireFish(){
    if (fishPool.length) { const m = fishPool.pop(); m.visible = true; return m; }
    const fish = new THREE.Group();
    const body = new THREE.Mesh(GEO.body, MAT.body); body.scale.set(1.6,1,1); fish.add(body);
    const tail = new THREE.Mesh(GEO.tail, MAT.tail); tail.rotation.z = Math.PI; tail.position.x = -0.28; fish.add(tail);
    const fin  = new THREE.Mesh(GEO.fin, MAT.fin); fin.rotation.z = Math.PI/2; fin.position.set(0.05, -0.08, 0); fish.add(fin);
    const eye1 = new THREE.Mesh(GEO.eye, MAT.eye); eye1.position.set(0.18, 0.06, 0.11); fish.add(eye1);
    const eye2 = eye1.clone(); eye2.position.z = -0.11; fish.add(eye2);
    return fish;
  }
  function releaseFish(f){ f.visible=false; scene.remove(f); fishPool.push(f); }

  function makeBaguette(){
    const g = new THREE.Group();
    const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.13, 1.0, 8, 16), new THREE.MeshStandardMaterial({ color:0xc78d4a, metalness:.1, roughness:.8 }));
    body.rotation.z = Math.PI/2; g.add(body);
    const cutsMat = new THREE.MeshStandardMaterial({ color:0xe4b680, metalness:.1, roughness:.9 });
    for (let i=0;i<5;i++){ const cut = new THREE.Mesh(new THREE.TorusGeometry(0.15, 0.02, 6, 16, Math.PI/2), cutsMat); cut.rotation.x = Math.PI/2; cut.position.x = -0.5 + i*0.25; g.add(cut); }
    return g;
  }

  // Input
  const keys = new Set();
  let yaw = 0, pitch = 0;
  let vel = new THREE.Vector3();
  const pos = new THREE.Vector3(0,1.7, -world.size/4);
  const up = new THREE.Vector3(0,1,0);
  const TMP = { forward:new THREE.Vector3(), right:new THREE.Vector3(), acc:new THREE.Vector3(), dir:new THREE.Vector3(), origin:new THREE.Vector3() };

  function lockPointer(){ renderer.domElement.requestPointerLock?.(); }
  function onMouseMove(e){ if (document.pointerLockElement === renderer.domElement) { const s = 0.0025; yaw -= e.movementX*s; pitch -= e.movementY*s; pitch = clamp(pitch, -Math.PI/2+0.05, Math.PI/2-0.05); } }
  function onKey(e,down){ if (down) keys.add(e.code); else keys.delete(e.code); if (e.code==='KeyN'&&down) toggleMute(); if (e.code==='KeyR'&&down) respawn(); }

  function dirFromAngles(){ return TMP.dir.set(Math.sin(yaw)*Math.cos(pitch), Math.sin(-pitch), Math.cos(yaw)*Math.cos(pitch)).normalize(); }

  function updateMovement(dt){
    const speed = (keys.has('ShiftLeft')||keys.has('ShiftRight')) ? 7 : 4.2;
    const forward = TMP.forward.set(Math.sin(yaw),0,Math.cos(yaw));
    const right = TMP.right.copy(forward).cross(up).multiplyScalar(-1);
    const acc = TMP.acc.set(0,0,0);
    if (keys.has('KeyW')||keys.has('ArrowUp')) acc.add(forward);
    if (keys.has('KeyS')||keys.has('ArrowDown')) acc.add(forward.clone().multiplyScalar(-1));
    if (keys.has('KeyA')||keys.has('ArrowLeft')) acc.add(right.clone().multiplyScalar(-1));
    if (keys.has('KeyD')||keys.has('ArrowRight')) acc.add(right);
    if (acc.lengthSq()>0) acc.normalize().multiplyScalar(speed);
    vel.lerp(acc, 1 - Math.exp(-10*dt));
    pos.addScaledVector(vel, dt);
    pos.x = clamp(pos.x, -world.size/2+1, world.size/2-1);
    pos.z = clamp(pos.z, -world.size/2+1, world.size/2-1);
    camera.position.copy(pos); camera.rotation.set(pitch, yaw, 0, 'ZYX');
  }

  // Combat
  let canThrow = true, canSwing = true;
  function throwFish(owner='me'){
    if (owner==='me' && !canThrow) return;
    const fish = acquireFish();
    const origin = TMP.origin.copy(camera.position);
    const dir = dirFromAngles();
    fish.position.copy(origin).addScaledVector(dir, 0.8);
    const speed = 18; const v = dir.clone().multiplyScalar(speed);
    scene.add(fish);
    projectiles.push({ owner, mesh:fish, vel:v, ttl:2.5 });
    if (owner==='me') { canThrow=false; setTimeout(()=>canThrow=true, 350); SFX.throw(); send({t:'throw', o:origin.toArray(), d:v.toArray()}); }
  }

  function swingBaguette(owner='me'){
    if (owner==='me' && !canSwing) return;
    const startRot = local.baguette.rotation.z; const targetRot = startRot + 1.2; const t0 = performance.now(); const dur = 180;
    (function anim(){ const u = Math.min(1, (performance.now()-t0)/dur); local.baguette.rotation.z = lerp(targetRot, startRot, (1-u)*(1-u)); if (u<1) requestAnimationFrame(anim); else local.baguette.rotation.z = startRot; })();
    if (owner==='me') { canSwing=false; setTimeout(()=>canSwing=true, 450); SFX.swing(); if (remoteConnected && remote.alive) { const toEnemy = new THREE.Vector3().copy(remote.model.position).sub(camera.position); const dist = toEnemy.length(); const fwd = dirFromAngles(); const facing = toEnemy.normalize().dot(fwd); if (dist < 2.2 && facing > 0.6) { send({ t:'hit', kind:'melee' }); } } send({t:'swing'}); }
  }

  function updateProjectiles(dt){
    for (let i=projectiles.length-1; i>=0; i--){
      const p = projectiles[i];
      p.mesh.position.addScaledVector(p.vel, dt);
      p.mesh.rotation.y += dt*10;
      p.ttl -= dt;
      if (Math.abs(p.mesh.position.x) > world.size/2-0.5 || Math.abs(p.mesh.position.z) > world.size/2-0.5) p.ttl=0;
      if (p.owner==='them' && local.alive) { if (p.mesh.position.distanceTo(camera.position) < 0.7) { onLocalHit('fish'); p.ttl=0; } }
      if (p.ttl<=0){ releaseFish(p.mesh); projectiles.splice(i,1); }
    }
  }

  function onLocalHit(){ if (!local.alive) return; local.hp = Math.max(0, local.hp-1); SFX.hit(); refreshHearts(); if (local.hp<=0){ local.alive=false; SFX.lose(); send({t:'dead'}); showToast('You lose'); } }
  function onRemoteHit(){ if (!remote.alive) return; remote.hp = Math.max(0, (remote.hp||3)-1); if (remote.hp<=0){ remote.alive=false; SFX.win(); showToast('You win'); } }

  // HUD
  function refreshHearts(){
    hud.innerHTML = '';
    for (let i=0;i<3;i++){
      const img = document.createElement('img'); img.className='heart'; img.alt='♥';
      img.src = i < local.hp
        ? 'data:image/svg+xml;utf8,' + encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#ff356d"><path d="M12 21s-7.5-4.35-10-8.5C-0.5 8 2.5 4.5 6 6.2c2 .98 3.1 3.1 3.6 3.8.5-.7 1.6-2.82 3.6-3.8 3.5-1.7 6.5 1.8 4 6.3C19.5 16.65 12 21 12 21z"/></svg>`)
        : 'data:image/svg+xml;utf8,' + encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="#5b6370" stroke-width="2"><path d="M12 21s-7.5-4.35-10-8.5C-0.5 8 2.5 4.5 6 6.2c2 .98 3.1 3.1 3.6 3.8.5-.7 1.6-2.82 3.6-3.8 3.5-1.7 6.5 1.8 4 6.3C19.5 16.65 12 21 12 21z"/></svg>`);
      hud.appendChild(img);
    }
  }

  // Networking
  let peer, conn, isHost=false, roomId; let remoteConnected=false;
  function setupNetworking(){
    roomId = ensureRoomUrl();
    const hostId = 'room-' + roomId;
    const forceClient = /[?&]client=1/.test(location.search);

    if (!forceClient) {
      isHost = true;
      peer = new Peer(hostId, { debug:0 });
      peer.on('open', ()=>{ setConnState('Waiting'); setShareLink(location.href); });
      peer.on('connection', c=>{ if (remoteConnected){ c.close(); return; } conn = c; bindConn(); remoteConnected = true; setConnState('Connected'); });
      peer.on('error', err=>{ if (String(err).includes('is taken')) { try{ peer.destroy(); }catch(_){} connectAsClient(hostId); } else { console.warn(err); showToast('Network error'); } });
    } else { connectAsClient(hostId); }
  }
  function connectAsClient(hostId){ isHost=false; peer = new Peer(undefined, { debug:0 }); peer.on('open', ()=>{ conn = peer.connect(hostId, { reliable:true }); bindConn(); }); peer.on('error', err=>{ console.warn(err); showToast('Network error'); }); }
  function bindConn(){ conn.on('open', ()=>{ remoteConnected=true; setConnState('Connected'); send({ t:'hello' }); }); conn.on('close', ()=>{ remoteConnected=false; setConnState('Disconnected'); }); conn.on('data', onNetData); }
  function send(obj){ try{ conn && conn.open && conn.send(obj); } catch(_){} }
  function setConnState(s){ connStateEl.textContent = s; }
  function setShareLink(url){ shareLinkEl.textContent = url; }

  function onNetData(msg){
    switch(msg.t){
      case 'hello': remote.model.visible = true; break;
      case 'state': if (!remote.model.visible) remote.model.visible = true; remote.model.position.fromArray(msg.p); remote.model.rotation.y = msg.y; break;
      case 'throw': { const fish = acquireFish(); fish.position.fromArray(msg.o); const p = { owner:'them', mesh:fish, vel:new THREE.Vector3().fromArray(msg.d), ttl:2.5 }; scene.add(fish); projectiles.push(p); } break;
      case 'swing': break;
      case 'hit': onRemoteHit(); break;
      case 'dead': SFX.win(); showToast('You win'); break;
    }
  }

  // Loop
  let lastSend = 0;
  function loop(){
    const dt = Math.min(0.05, clock.getDelta());
    updateMovement(dt);
    updateProjectiles(dt);
    const now = performance.now();
    if (remoteConnected && now - lastSend > 50){ send({ t:'state', p:[camera.position.x, camera.position.y, camera.position.z], y: yaw }); lastSend = now; }
    renderer.render(scene, camera);
    requestAnimationFrame(loop);
  }

  // Controls
  function onClick(e){ if (e.button===0) throwFish('me'); if (e.button===2) swingBaguette('me'); }
  function onContext(e){ e.preventDefault(); }
  function respawn(){ local.hp=3; local.alive=true; refreshHearts(); showToast('Respawned'); pos.set(0,1.7, -world.size/4); yaw=0; pitch=0; }
  function toggleMute(){ const m = SFX.toggle(); muteBtn.textContent = m? 'Unmute':'Mute'; }

  copyBtn.addEventListener('click', async()=>{ try{ await navigator.clipboard.writeText(location.href); showToast('Link copied'); } catch(_){ showToast('Copy failed'); } });
  muteBtn.addEventListener('click', toggleMute);

  function start(){
    overlay.style.display = 'none';
    setupThree();
    refreshHearts();
    renderer.domElement.addEventListener('click', onClick);
    renderer.domElement.addEventListener('contextmenu', onContext);
    renderer.domElement.addEventListener('mousedown', ()=>{ if (document.pointerLockElement !== renderer.domElement) lockPointer(); });
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('keydown', e=>onKey(e,true));
    window.addEventListener('keyup', e=>onKey(e,false));
    if (SFX.ctx.state === 'suspended') SFX.ctx.resume();
    setupNetworking();
    setShareLink(location.href);
    remote.model.position.set(0,0,-2);
    clock.start();
    loop();
  }
  startBtn.addEventListener('click', start);

  const room = ensureRoomUrl();
  setShareLink(location.href);

  </script>
</body>
</html>
