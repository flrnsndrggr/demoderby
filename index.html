<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Fish Duel — P2P FPS</title>
  <style>
    :root { color-scheme: dark; }
    html, body { margin:0; height:100%; overflow:hidden; background:#0b0f14; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    #ui { position:fixed; inset:0; display:grid; place-items:center; pointer-events:none; }
    .panel { pointer-events:auto; width:min(820px, 92vw); background:#0f172a; color:#e5e7eb; border:1px solid #1f2937; border-radius:16px; padding:20px; box-shadow:0 10px 40px rgba(0,0,0,.5); }
    h1 { margin:0 0 8px; font-size:24px; }
    p { margin:6px 0; color:#cbd5e1; }
    .row { display:flex; gap:8px; flex-wrap:wrap; }
    input[type="text"], textarea { flex:1 1 340px; min-height:44px; padding:10px 12px; border-radius:12px; border:1px solid #334155; background:#0b1220; color:#e5e7eb; resize:vertical; }
    button { height:44px; padding:0 14px; border-radius:12px; border:1px solid #334155; background:#111827; color:#e5e7eb; cursor:pointer; font-weight:600; }
    button.primary { background:#2563eb; border-color:#1d4ed8; }
    button:disabled { opacity:.6; cursor:not-allowed; }
    .muted { color:#94a3b8; font-size:12px; }
    #hud { position:fixed; inset:0; pointer-events:none; }
    #hud .top { position:absolute; top:12px; left:12px; display:flex; gap:8px; align-items:center; }
    #hud .right { position:absolute; top:12px; right:12px; text-align:right; color:#cbd5e1; }
    .heart { width:18px; height:18px; border:2px solid #94a3b8; border-radius:4px; box-shadow: inset 0 0 0 999px #111827; }
    .heart.alive { box-shadow: inset 0 0 0 999px #22c55e; border-color:#16a34a; }
    #center { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); color:#cbd5e1; text-align:center; }
    #crosshair { width:8px; height:8px; border:2px solid #e5e7eb; border-radius:50%; opacity:.9; margin:0 auto 8px; }
    #notice { font-size:13px; color:#94a3b8; }
    #startOverlay { position:fixed; inset:0; display:none; place-items:center; background:rgba(0,0,0,.6); color:#e5e7eb; }
    #startOverlay .bubble { background:#0f172a; border:1px solid #1f2937; padding:18px 22px; border-radius:14px; }
    canvas { display:block; width:100vw; height:100vh; }
    #baguette { position:fixed; right:18px; bottom:8vh; width:520px; height:220px; transform-origin:90% 90%; transform:rotateZ(12deg); opacity:.98; pointer-events:none; filter: drop-shadow(0 12px 24px rgba(0,0,0,.45)); display:none; }
    #baguette svg { width:100%; height:100%; }
    #toast { position:fixed; bottom:14px; left:50%; transform:translateX(-50%); background:#111827; border:1px solid #223; padding:8px 12px; border-radius:10px; color:#cbd5e1; display:none; }
  </style>
</head>
<body>
  <div id="ui">
    <div class="panel" id="connectPanel">
      <h1>Fish Duel — P2P 1v1</h1>
      <p>Throw fish at your rival. Three hits and you lose. Melee with a baguette. 1v1. Works peer to peer in the browser via WebRTC. No server required, just a quick copy paste to finish the handshake.</p>
      <p class="muted">Controls: Click to lock mouse. WASD to move, Space to jump, Shift to sprint, Left click to throw fish, Right click or F to baguette melee, N to toggle name tags, M to mute sfx.</p>
      <hr style="border:none; border-top:1px solid #233; margin:12px 0;">
      <div class="row">
        <button class="primary" id="btnHost">Host match</button>
        <button id="btnJoin">Join match</button>
        <button id="btnRandom">Quick pair</button>
      </div>
      <p id="hostStep" class="muted" style="display:none">1) Copy the invite link and send it to your opponent. 2) When they give you back an Answer Code, paste it below and press Connect.</p>
      <div class="row" id="hostRow" style="display:none; margin-top:8px;">
        <input id="inviteLink" type="text" readonly />
        <button id="copyInvite">Copy link</button>
      </div>
      <div class="row" id="hostRow2" style="display:none; margin-top:8px;">
        <textarea id="answerBox" placeholder="Paste Answer Code here"></textarea>
        <button id="btnConnectAnswer" class="primary">Connect</button>
      </div>
      <div id="joinStep" style="display:none; margin-top:8px;">
        <p class="muted">Open your friend's link. If this page already contains their Offer Code, click Generate Answer then send the code back. It is auto copied.</p>
        <div class="row">
          <textarea id="offerBox" placeholder="Paste Offer Code here (unless it auto appeared)"></textarea>
        </div>
        <div class="row" style="margin-top:8px;">
          <button id="btnMakeAnswer" class="primary">Generate Answer</button>
          <button id="btnCopyAnswer">Copy Answer</button>
        </div>
      </div>
      <p class="muted" id="status"></p>
    </div>
  </div>

  <div id="hud" style="display:none">
    <div class="top">
      <div class="heart" id="h1"></div>
      <div class="heart" id="h2"></div>
      <div class="heart" id="h3"></div>
    </div>
    <div class="right">
      <div id="names"></div>
      <div id="ping" class="muted"></div>
    </div>
    <div id="center">
      <div id="crosshair"></div>
      <div id="notice">Left click to throw fish · Right click / F to baguette · ESC to unlock cursor</div>
    </div>
  </div>

  <div id="startOverlay"><div class="bubble"><strong>Click to start</strong><div class="muted">Grant mouse lock to play</div><div style="margin-top:10px; display:flex; gap:8px; justify-content:flex-end;"><button id="btnCloseOverlay">Close</button></div></div></div>

  <div id="baguette" aria-hidden="true">
    <!-- Simple baguette vector -->
    <svg viewBox="0 0 300 120" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <linearGradient id="g" x1="0" x2="1">
          <stop offset="0" stop-color="#f4a261"/>
          <stop offset="1" stop-color="#e76f51"/>
        </linearGradient>
      </defs>
      <ellipse cx="150" cy="60" rx="140" ry="44" fill="url(#g)" stroke="#7c3f2b" stroke-width="4"/>
      <path d="M40,60 q40,-40 80,0 q40,40 80,0 q40,-40 80,0" fill="none" stroke="#fef3c7" stroke-width="6" stroke-linecap="round"/>
    </svg>
  </div>
  <div id="toast"></div>

  <canvas id="game"></canvas>

  <!-- Three.js from CDN -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
  // ====== Small helpers ======
  const $ = sel => document.querySelector(sel);
  const $$ = sel => Array.from(document.querySelectorAll(sel));
  const toast = (t) => { const el = $('#toast'); el.textContent = t; el.style.display = 'block'; clearTimeout(toast._t); toast._t = setTimeout(()=>{ el.style.display='none'; }, 2200); };
  const enc = (obj) => btoa(unescape(encodeURIComponent(JSON.stringify(obj))));
  const dec = (b64) => JSON.parse(decodeURIComponent(escape(atob(b64))));

  // ====== WebRTC P2P (copy paste signaling) ======
  const iceServers = [ { urls: 'stun:stun.l.google.com:19302' }, { urls: 'stun:global.stun.twilio.com:3478?transport=udp' } ];
  let pc, dc, isHost = false, connected = false, lastPing = 0, pingRTT = 0;

  const waitIce = (pc) => new Promise(res => {
    if (pc.iceGatheringState === 'complete') return res();
    const check = () => { if (pc.iceGatheringState === 'complete') { pc.removeEventListener('icegatheringstatechange', check); res(); } };
    pc.addEventListener('icegatheringstatechange', check);
  });

  async function createPeer() {
    pc = new RTCPeerConnection({ iceServers });
    pc.onconnectionstatechange = () => { $('#status').textContent = `Connection: ${pc.connectionState}`; if (pc.connectionState === 'connected') onConnected(); };
    pc.oniceconnectionstatechange = () => { if (pc.iceConnectionState === 'failed') toast('ICE failed. Try again.'); };
    pc.ondatachannel = (ev) => { dc = ev.channel; wireDC(); };
  }

  function wireDC() {
    dc.binaryType = 'arraybuffer';
    dc.onopen = () => { connected = true; $('#ui').style.display = 'none'; $('#hud').style.display = 'block'; $('#startOverlay').style.display='grid'; toast('Connected'); send({ t:'hello', name: myName }); };
    dc.onclose = () => { connected = false; toast('Disconnected'); };
    dc.onmessage = (ev) => handleNetMessage(ev.data);
  }

  function send(obj) { if (dc && dc.readyState === 'open') dc.send(JSON.stringify(obj)); }

  async function hostFlow() {
    isHost = true; await createPeer();
    dc = pc.createDataChannel('game'); wireDC();
    const offer = await pc.createOffer(); await pc.setLocalDescription(offer); await waitIce(pc);
    const offerCode = enc({ sdp: pc.localDescription });
    const url = new URL(location.href); url.searchParams.set('offer', offerCode); $('#inviteLink').value = url.toString();
    $('#hostStep').style.display = 'block'; $('#hostRow').style.display='flex'; $('#hostRow2').style.display='flex';
  }

  async function joinFlowFromOffer(offerCode) {
    await createPeer();
    const { sdp } = dec(offerCode);
    await pc.setRemoteDescription(sdp);
    const answer = await pc.createAnswer(); await pc.setLocalDescription(answer); await waitIce(pc);
    const answerCode = enc({ sdp: pc.localDescription });
    $('#offerBox').value = offerCode;
    $('#joinStep').style.display='block';
    $('#btnMakeAnswer').disabled = true; $('#btnCopyAnswer').disabled = false;
    $('#btnCopyAnswer').dataset.answer = answerCode;
    try { await navigator.clipboard.writeText(answerCode); toast('Answer copied to clipboard'); } catch {}
  }

  async function applyAnswer(answerCode) {
    const { sdp } = dec(answerCode);
    await pc.setRemoteDescription(sdp);
  }

  // Quick pair: generates a short room id in location.hash that both players can share out of band.
  function quickPair() {
    const room = Math.random().toString(36).slice(2,8);
    const url = new URL(location.href); url.hash = `#${room}`; history.replaceState({}, '', url);
    $('#status').textContent = `Room created: ${room}. Click Host, send link, paste back Answer.`;
    toast('Room code set in URL');
  }

  // ====== Minimal FPS game ======
  const canvas = $('#game');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
  const scene = new THREE.Scene(); scene.background = new THREE.Color(0x0b0f14);
  const camera = new THREE.PerspectiveCamera(70, 1, 0.1, 1000);
  const clock = new THREE.Clock();

  // Lighting and simple arena
  const hemi = new THREE.HemisphereLight(0xbde0ff, 0x0a0a15, 0.8); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.45); dir.position.set(5,10,2); scene.add(dir);
  const floorGeo = new THREE.PlaneGeometry(200,200, 40,40);
  floorGeo.rotateX(-Math.PI/2);
  const floorMat = new THREE.MeshStandardMaterial({ color:0x112233, wireframe:false });
  const floor = new THREE.Mesh(floorGeo, floorMat); scene.add(floor);
  // Some pillars
  const pillars = new THREE.Group();
  for (let i=0;i<16;i++) {
    const g = new THREE.CylinderGeometry(0.6,0.6,4,10);
    const m = new THREE.MeshStandardMaterial({ color:0x1f2a44 });
    const c = new THREE.Mesh(g,m);
    c.position.set((Math.random()*2-1)*20, 2, (Math.random()*2-1)*20);
    pillars.add(c);
  }
  scene.add(pillars);

  // Player state
  const input = { fwd:0, str:0, up:false, sprint:false, mouseLocked:false, melee:false, throw:false };
  let yaw = 0, pitch = 0; const vel = new THREE.Vector3(); const pos = new THREE.Vector3(0,1.6, 10);
  let hp = 3, otherHP = 3; const nameTags = { show:true };
  let myName = `Player-${Math.random().toString(36).slice(2,6)}`;

  // Opponent proxy
  const foe = new THREE.Mesh(new THREE.CapsuleGeometry(0.4, 1.0, 8, 16), new THREE.MeshStandardMaterial({ color:0x8b5cf6 }));
  foe.position.set(0,1, -10); scene.add(foe);

  // Fish projectiles
  const fishes = []; // {mesh, vel, owner:'me'|'them'}
  function makeFish(owner='me') {
    const g = new THREE.Group();
    // Body
    const bodyMat = new THREE.MeshStandardMaterial({ color: owner==='me'?0x22c55e:0xf59e0b, metalness:0.1, roughness:0.6 });
    const body = new THREE.Mesh(new THREE.SphereGeometry(0.22, 16, 12), bodyMat);
    body.scale.set(1.6, 0.9, 0.9);
    // Tail
    const tail = new THREE.Mesh(new THREE.ConeGeometry(0.16, 0.32, 16), new THREE.MeshStandardMaterial({ color:0x9ca3af }));
    tail.rotation.z = Math.PI; tail.position.z = -0.46;
    // Fins
    const finMat = new THREE.MeshStandardMaterial({ color:0x9ca3af, roughness:0.5 });
    const dorsal = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.16, 10), finMat); dorsal.rotation.x = Math.PI; dorsal.position.set(0,0.18,-0.06);
    const pFinL = new THREE.Mesh(new THREE.ConeGeometry(0.07, 0.14, 10), finMat); pFinL.rotation.y = Math.PI/2; pFinL.position.set(0.18,-0.02,0);
    const pFinR = pFinL.clone(); pFinR.position.x = -0.18; pFinR.rotation.y *= -1;
    // Eyes
    const eyeGeo = new THREE.SphereGeometry(0.04, 8, 8);
    const eyeL = new THREE.Mesh(eyeGeo, new THREE.MeshStandardMaterial({ color:0x111111 }));
    const eyeR = eyeL.clone();
    eyeL.position.set(0.22, 0.03, 0.08);
    eyeR.position.set(0.22, 0.03, -0.08);
    g.add(body, tail, dorsal, pFinL, pFinR, eyeL, eyeR);
    g.userData.tail = tail;
    g.userData.fins = [pFinL, pFinR];
    scene.add(g); return g;
  }

  function throwFish(isLocal=true) {
    const m = makeFish(isLocal?'me':'them');
    let startPos, dirVec;
    if (isLocal) {
      startPos = camera.position.clone();
      dirVec = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
    } else {
      startPos = foe.position.clone().add(new THREE.Vector3(0,0.6,0));
      dirVec = foe.getWorldDirection(new THREE.Vector3());
    }
    m.position.copy(startPos.add(dirVec.clone().multiplyScalar(0.8)));
    const speed = isLocal ? 16 : 14;
    fishes.push({ mesh:m, vel:dirVec.multiplyScalar(speed), owner: isLocal?'me':'them' });
    if (isLocal) send({ t:'throw' });
    sfx('throw');
  }

  // Melee baguette swing
  const baguetteEl = $('#baguette'); let swingT = 0;
  function swing() {
    swingT = 1; baguetteEl.style.display='block'; sfx('melee');
    // Hit check: close enough and roughly in front
    const toFoe = foe.position.clone().sub(camera.position);
    const dist = toFoe.length();
    const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
    const facing = fwd.dot(toFoe.normalize());
    if (dist < 2.2 && facing > 0.5) registerHit('foe');
    send({ t:'melee' });
  }

  function registerHit(target) {
    if (target==='me') {
      hp = Math.max(0, hp-1); updateHearts(); sfx('hit'); if (hp===0) { send({ t:'youwin' }); gameOver(false); }
    } else {
      otherHP = Math.max(0, otherHP-1); if (otherHP===0) gameOver(true); // client side win
      send({ t:'hit' });
    }
  }

  function updateHearts() {
    for (let i=1;i<=3;i++) $('#h'+i).className = 'heart '+(i<=hp?'alive':'');
  }

  function gameOver(win) {
    toast(win? 'You win' : 'You lose');
    $('#notice').textContent = win ? 'Victory' : 'Defeat';
    // Freeze controls a bit
    setTimeout(()=>{ document.exitPointerLock?.(); }, 800);
  }

  // Resize
  function onResize() {
    const w = window.innerWidth, h = window.innerHeight;
    renderer.setSize(w, h, false); camera.aspect = w/h; camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', onResize);
  onResize();

  // Input
  const keys = new Set();
  window.addEventListener('keydown', e=>{
    if (e.repeat) return;
    const k = e.code;
    if (['KeyW','KeyA','KeyS','KeyD','ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space','ShiftLeft','ShiftRight'].includes(k)) e.preventDefault();
    if (k==='KeyW' || k==='ArrowUp') keys.add('w');
    if (k==='KeyS' || k==='ArrowDown') keys.add('s');
    if (k==='KeyA' || k==='ArrowLeft') keys.add('a');
    if (k==='KeyD' || k==='ArrowRight') keys.add('d');
    if (k==='Space') keys.add('space');
    if (k==='ShiftLeft' || k==='ShiftRight') keys.add('shift');
    if (k==='KeyF') swing();
    if (k==='KeyN') { nameTags.show = !nameTags.show; updateNames(); }
    if (k==='KeyM') { audioMuted = !audioMuted; toast(audioMuted?'Muted':'Sound on'); }
  });
    if (e.code==='KeyS' || e.code==='ArrowDown') keys.add('s');
    if (e.code==='KeyA' || e.code==='ArrowLeft') keys.add('a');
    if (e.code==='KeyD' || e.code==='ArrowRight') keys.add('d');
    if (e.code==='Space') keys.add('space');
    if (e.code==='ShiftLeft' || e.code==='ShiftRight') keys.add('shift');
    if (e.code==='KeyF') swing();
    if (e.code==='KeyN') { nameTags.show = !nameTags.show; }
    if (e.code==='KeyM') { audioMuted = !audioMuted; toast(audioMuted?'Muted':'Sound on'); }
  });
  window.addEventListener('keyup', e=>{
    const k = e.code;
    if (['KeyW','KeyA','KeyS','KeyD','ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space','ShiftLeft','ShiftRight'].includes(k)) e.preventDefault();
    if (k==='KeyW' || k==='ArrowUp') keys.delete('w');
    if (k==='KeyS' || k==='ArrowDown') keys.delete('s');
    if (k==='KeyA' || k==='ArrowLeft') keys.delete('a');
    if (k==='KeyD' || k==='ArrowRight') keys.delete('d');
    if (k==='Space') keys.delete('space');
    if (k==='ShiftLeft' || k==='ShiftRight') keys.delete('shift');
  });
    if (e.code==='KeyS' || e.code==='ArrowDown') keys.delete('s');
    if (e.code==='KeyA' || e.code==='ArrowLeft') keys.delete('a');
    if (e.code==='KeyD' || e.code==='ArrowRight') keys.delete('d');
    if (e.code==='Space') keys.delete('space');
    if (e.code==='ShiftLeft' || e.code==='ShiftRight') keys.delete('shift');
  });

  canvas.addEventListener('click', ()=>{
    if (document.pointerLockElement !== canvas) {
      canvas.requestPointerLock?.(); return;
    }
    throwFish(true);
  });
  canvas.addEventListener('contextmenu', e=>{ e.preventDefault(); swing(); });
  document.addEventListener('pointerlockchange', ()=>{
    const locked = document.pointerLockElement === canvas;
    $('#startOverlay').style.display = locked? 'none':'grid';
  });
  // Close overlay button support
  document.addEventListener('click', (e)=>{
    if (e.target && e.target.id === 'btnCloseOverlay') {
      $('#startOverlay').style.display = 'none';
    }
  });
  document.addEventListener('mousemove', (e)=>{
    if (document.pointerLockElement !== canvas) return;
    const sensitivity = 0.0025;
    yaw -= e.movementX * sensitivity;
    pitch -= e.movementY * sensitivity; pitch = Math.max(-1.4, Math.min(1.4, pitch));
  });

  // Simple kinematics
  const tmp = new THREE.Vector3();
  function step(dt) {
    const speed = (keys.has('shift')? 7.2: 4.2);
    tmp.set(0,0,0);
    if (keys.has('w')) tmp.z -= 1;
    if (keys.has('s')) tmp.z += 1;
    if (keys.has('a')) tmp.x -= 1;
    if (keys.has('d')) tmp.x += 1;
    if (tmp.lengthSq()>0) tmp.normalize();
    // rotate by yaw
    const sin=Math.sin(yaw), cos=Math.cos(yaw);
    const dx = tmp.x * cos - tmp.z * sin;
    const dz = tmp.x * sin + tmp.z * cos;
    pos.x += dx * speed * dt;
    pos.z += dz * speed * dt;
    // keep in arena
    pos.x = Math.max(-45, Math.min(45, pos.x));
    pos.z = Math.max(-45, Math.min(45, pos.z));

    // camera from pos
    camera.position.copy(pos);
    camera.rotation.set(pitch, yaw, 0, 'YXZ');

    // Animate baguette swing
    if (swingT>0) { swingT = Math.max(0, swingT - dt*2.8); const a = Math.sin((1-swingT)*Math.PI)*38; $('#baguette').style.transform = `rotateZ(${12+a}deg)`; if (swingT===0) $('#baguette').style.display='none'; }

    // Projectiles update
    for (let i=fishes.length-1;i>=0;i--) {
      const f = fishes[i];
      f.mesh.position.addScaledVector(f.vel, dt);
      // Face direction of travel
      const lookTarget = f.mesh.position.clone().add(f.vel);
      f.mesh.lookAt(lookTarget);
      // Animate tail and fins
      if (!f.phase) f.phase = Math.random()*Math.PI*2;
      f.phase += dt*12;
      if (f.mesh.userData.tail) f.mesh.userData.tail.rotation.y = Math.sin(f.phase)*0.6;
      const fins = f.mesh.userData.fins||[]; fins.forEach((fin,idx)=>{ fin.rotation.z = Math.sin(f.phase + idx)*0.3; });
      // hit tests
      if (f.owner==='me') {
        const d = f.mesh.position.distanceTo(foe.position.clone().add({x:0,y:0.8,z:0}));
        if (d < 0.9) { registerHit('foe'); scene.remove(f.mesh); fishes.splice(i,1); continue; }
      } else {
        const d2 = f.mesh.position.distanceTo(camera.position.clone().add({x:0,y:0.8,z:0}));
        if (d2 < 0.9) { registerHit('me'); scene.remove(f.mesh); fishes.splice(i,1); continue; }
      }
      // lifetime
      if (f.mesh.position.length() > 400) { scene.remove(f.mesh); fishes.splice(i,1); }
    }

    // Send state ~30 Hz
    if (connected) {
      const now = performance.now();
      if (!lastPing || now-lastPing>33) {
        send({ t:'state', p:[pos.x,pos.y,pos.z], r:[yaw,pitch] });
        lastPing = now;
      }
    }
  }

  // Render loop
  function loop() {
    const dt = Math.min(0.033, clock.getDelta());
    step(dt);
    renderer.render(scene, camera);
    requestAnimationFrame(loop);
  }
  loop();

  // Networking message handler
  function handleNetMessage(data) {
    try { var msg = JSON.parse(data); } catch { return; }
    if (msg.t==='hello') { foe.name = msg.name || 'Opponent'; updateNames(); }
    if (msg.t==='state' && Array.isArray(msg.p)) {
      foe.position.set(msg.p[0], msg.p[1]-0.6, msg.p[2]);
      // Rotate foe to face yaw
      const y = msg.r?.[0]||0; foe.rotation.y = y;
    }
    if (msg.t==='throw') throwFish(false);
    if (msg.t==='melee') { // did they hit us?
      const toMe = camera.position.clone().sub(foe.position); const dist = toMe.length(); const facing = new THREE.Vector3(0,0,-1).applyEuler(new THREE.Euler(0, foe.rotation.y, 0)).dot(toMe.normalize());
      if (dist < 2.2 && facing > 0.5) registerHit('me'); sfx('melee');
    }
    if (msg.t==='hit') { otherHP = Math.max(0, otherHP-1); if (otherHP===0) gameOver(true); }
    if (msg.t==='youwin') gameOver(true);
    if (msg.t==='name') { foe.name = msg.name; updateNames(); }
    if (msg.t==='ping') { dc.send(JSON.stringify({t:'pong', n:msg.n})); }
    if (msg.t==='pong') { const dt = performance.now()-msg.n; pingRTT=dt; $('#ping').textContent = `Ping ${Math.round(dt)} ms`; }
  }

  function updateNames() {
    $('#names').innerHTML = nameTags.show? `<div>You: ${myName}</div><div>Rival: ${foe.name||'Opponent'}</div>` : '';
  }

  // Periodic ping
  setInterval(()=>{ if (dc && dc.readyState==='open') dc.send(JSON.stringify({t:'ping', n:performance.now()})); }, 2000);

  // Basic SFX
  let audioCtx; let audioMuted = false;
  function sfx(type) {
    if (audioMuted) return;
    audioCtx = audioCtx || new (window.AudioContext||window.webkitAudioContext)();
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.connect(g); g.connect(audioCtx.destination);
    if (type==='throw') { o.type='triangle'; o.frequency.setValueAtTime(560,audioCtx.currentTime); g.gain.value=.04; g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+0.2); }
    else if (type==='melee') { o.type='square'; o.frequency.setValueAtTime(180,audioCtx.currentTime); g.gain.value=.07; g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+0.08); }
    else if (type==='hit') { o.type='sawtooth'; o.frequency.setValueAtTime(120,audioCtx.currentTime); g.gain.value=.08; g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+0.3); }
    o.start(); o.stop(audioCtx.currentTime+0.35);
  }

  // ====== UI wiring ======
  $('#btnHost').onclick = hostFlow;
  $('#btnJoin').onclick = ()=>{ $('#joinStep').style.display='block'; };
  $('#btnRandom').onclick = quickPair;
  $('#copyInvite').onclick = async ()=>{ try { await navigator.clipboard.writeText($('#inviteLink').value); toast('Invite link copied'); } catch{} };
  $('#btnConnectAnswer').onclick = ()=>{ const a = $('#answerBox').value.trim(); if (!a) return; applyAnswer(a); };
  $('#btnMakeAnswer').onclick = async ()=>{ const off = $('#offerBox').value.trim(); if (!off) return; await joinFlowFromOffer(off); };
  $('#btnCopyAnswer').onclick = async (e)=>{ const v = e.target.dataset.answer; if (!v) return; try { await navigator.clipboard.writeText(v); toast('Answer copied'); } catch{} };

  // Autofill from URL ?offer=
  (function init() {
    // Hearts init
    updateHearts();
    // Name randomize once
    myName = localStorage.getItem('fishduel_name') || myName; localStorage.setItem('fishduel_name', myName);
    updateNames();

    const u = new URL(location.href);
    const offer = u.searchParams.get('offer');
    if (offer) { $('#connectPanel').scrollIntoView({behavior:'instant'}); $('#status').textContent = 'Offer detected from link'; joinFlowFromOffer(offer); }
  })();

  // Start overlay click
  $('#startOverlay').addEventListener('click', ()=> canvas.requestPointerLock?.());

  // Send our name after connect
  setInterval(()=>{ if (connected) send({t:'name', name: myName}); }, 4000);

  </script>
</body>
</html>
